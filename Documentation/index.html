<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Scholarly HTML</title>
    <link rel="stylesheet" href="css/scholarly.min.css">
    <script src="js/scholarly.min.js"></script>
  </head>
  <body prefix="schema: http://schema.org">
    <header>
      <div class="banner">
        <div class="status">Tehnologii Web</div>
      </div>
      <h1>REST vs GraphQL</h1>
    </header>

    <div role="contentinfo">
      <dl>
        <dt>Author</dt>
        <dd>
          <a href="https://github.com/Alintdg">Jufa Alin</a>
        </dd>
      </dl>
    </div>
    <section typeof="sa:Abstract" id="abstract" role="doc-abstract">
      <h2>Abstract</h2>

      <p>
        If you have written code for any modern platform, you’ve almost certainly interacted with a web API, more often than not, that API was probably REST. If you’ve been programming for a long time or have used a slightly older system, that API may have even been SOAP.
      <br>
      GraphQL is progressively gaining attention in the past years. Which leads us to the obvious questions: What is GraphQL? And how does it compare to the REST APIs that are used in most applications? The goal of this report is to help answer these questions and understand the key differences between both approaches. 
      </p>

      
    </section>
    <section id="introduction" role="doc-introduction">
      <h2>Introduction</h2>

      <p>
        In this article we'll be taking a look over the main differences between REST and GraphQL but also over in-depth differences regarding transfer methods, resource categories, performance, security, compatibility and maintenance.<br>
        GraphQL is well known as a Query Language for APIs that allows declarative data fetching to give the client the power to specify the data required from the API.<br>
         GraphQL makes it easier to evolve APIs over time. GraphQL was developed by Facebook in 2012 before being Open-sourced in 2015.

        REST API is defined as a Software Architectural Style built to guide the development and design of the architecture for the World Wide Web. <br>
        REST APIs define a set of constraints on how the architecture of a distributed system should behave.
      </p>

      <section id="REST">
        <h3> What is REST?</h3>
        <img src="images/REST.jpeg" alt="REST structure image" style="width:900px;height:400px;">

        <p>
          REST APIs provide a flexible, lightweight way of integrating applications. REST APIs allow you to search for some items, and then the results will be returned from the service you requested from.<br> A REST API has the following components:
        </p>
        <ul>
          <li><b>The Headers</b> : Headers refer to the Authentication Mode and the Content Types.</li> <br>
          <li><b>The Method</b> : There are various methods that you can use to call a REST API, the most common ones being POST and GET. The GET method is used to gather information while the POST method can be used to send information to the resources on the web.</li> <br>
          <li><b>The Endpoint</b> :  The Endpoint is defined as the URL of the resource to which you are going to place the requests. For instance, https://swapi.dev/api/.</li> <br>
          <li><b>The Data or Body</b> : This refers to the textual data in the form of JSON, which needs to be sent to the resource.</li> <br>
          </ul>

        

      </section>

      <section id="GraphQL">
        <h3> What is GraphQL?</h3>
        <img src="images/GraphQL1.jpeg" alt="GraphQL structue image" style="width:800px;height:400px;">

        <p>
          GraphQL is a Query Language that can be used to work with APIs. It enables the client to make HTTP requests and get responses. <br>
          As the name suggests, any set of information in GraphQL is seen in the context of a graph. Nodes defined under the GraphQL Schema System are used to depict objects. Edges between these nodes are used to represent the connection between the nodes of a graph.<br>
          This ensures clear relationships between queries and improves the connectivity between objects. GraphQL can also allow the users to request data from various resources using a single request.<br>
          As opposed to making multiple requests to fetch data, you can use GraphQL to make ad-hoc queries to a single endpoint and access all the necessary data.<br>
        </p>

        <img src="images/GraphQL2.jpeg" alt="GraphQL structue image" style="width:850px;height:400px;">

        <p>GraphQL API uses three main components:</p>
        <ul>
          <p><li><b>Queries. </b> A query is the request the client makes. Query fields can point to arrays and support arguments.</li></p>
          <p><li><b>Resolvers.</b> The GraphQL server won’t know what to do with the queries it gets unless you tell it. This is done using a resolver. In simple terms, a resolver tells GraphQL how (and where) to fetch the data corresponding to a specific field. With GraphQL, the API schema and database schemas you use are decoupled. This allows you to use them as mutation resolvers to modify the contents of your database.</li></p>
            <p><li><b>Schema.</b> A GraphQL schema describes the functionality clients can utilize once they connect to the GraphQL server. The core building block within schemas is called a type.</li></p>
        </ul>

     

              
        

      </section>
    </section>
    <section id="design">
     
      <h2>Design principles</h2>

      <p>Design principles are a set of considerations that form the basis of any good product. In other words, design principles are the foundation upon which good products are built.</p>
      <section id="RESTdesign">
      <h3>Here are REST design principles that are integral for the smooth functioning of a REST API:</h3>

      <ul>
      <li><b>Client-Server Decoupling</b> : In REST API design, Server and Client applications must be completely independent of each other. The only information available to the Client-side should be the URI of the requested resource. Similarly, a server application shouldn’t change the client application other than passing the requested data through HTTP. </li>  <br>
      <li><b>Statelessness</b> :REST APIs are Stateless. This means that each request should contain all the information required to process it. This can also mean that REST APIs don’t require any server-side sessions. Server applications aren’t permitted to store any data related to the client request.</li> <br>
      <li><b>Cacheability</b> : Whenever possible, resources should be Cacheable on the Server or Client-side. Server responses should also contain information on whether caching is allowed for the delivered resource. You should aim for improving performance on the client side while increasing scalability on the server side.</li> <br>
      <li><b>Uniform Interface</b> : All API requests for the same resource should look the same, irrespective of where the request comes from. The REST API should ensure that the same piece of data, like the email address or name of a user, belongs to only one Uniform Resource Identifier (URI). Resources shouldn’t be too huge but should contain every piece of information that the client may need.</li> <br>
      <li><b>Layered System Architecture</b> :  In REST APIs the responses and calls go through different layers. You shouldn’t assume that the Client and Server applications connect directly to each other. There may be various intermediaries involved in the communication loop. Therefore, REST APIs need to be designed such that neither the server nor the client can tell whether it communicates with an intermediary or an end application.</li> <br>
    </ul>

  </section>
  <section id="GraphQLdesign">
      <h3>Here are GraphQL design principles that are integral for the smooth functioning of a GraphQL API:</h3>
      <h4>Integrity Principles</h4>
        <ul><b>One Graph.</b>   <i>Your company should have one unified graph, instead of multiple graphs created by each team.</i> <br>
         <p>By having one graph, you maximize the value of GraphQL: </p> 
            <ul>
              <li>More data and services can be accessed from a single query </li>
              <li> Code, queries, skills, and experience are portable across teams</li>
              <li> One central catalog of all available data that all graph users can look to</li>
              <li> Implementation cost is minimized, because graph implementation work isn't duplicated</li>
              <li> Central management of the graph – for example, unified access control policies – becomes possible</li>
            </ul><br>
          

           <b>Federated Implementation.</b> <i>Though there is only one graph, the implementation of that graph should be federated across multiple teams.</i> <br>
            <p> Monolithic architectures are difficult to scale without highly specialized infrastructure, and graphs are no exception. Instead of implementing an organization's entire graph layer in a single codebase, responsibility for defining and implementing the graph should be divided across multiple teams.<br> Each team should be responsible for maintaining the portion of the schema that exposes their data and services, while having the flexibility to develop independently and operate on their own release cycle.</p> 
            This maintains the value of a single, unified view of the graph, while keeping development efforts across the company decoupled. <br>
            <br>
          <b>Track the Schema in a Registry.</b> <i>There should be a single source of truth for registering and tracking the graph.</i> <br>
           <p>Just like it's important to track source code in a version control system, it's important to track the definition of your graph in a schema registry. There should be a single schema registry for your company that is the authoritative definition of the graph, rather than relying on whatever processes are running at the moment or whatever code is checked in on a developer's laptop. <br> Like a source control system, the schema registry should store the history of changes to the graph and who made them, and it should understand the concept of multiple versions of the graph (for example, staging and production, or different development branches) in a way that parallels the software development process.</p>
          </ul>
            <h4>Agility Principles</h4>
            <ul>
            <b>Abstract, Demand-Oriented Schema. </b> <i> The schema should act as an abstraction layer that provides flexibility to consumers while hiding service implementation details.</i>
           <p>A large part of the value of GraphQL lies in providing an abstraction between services and consumers, so the schema should not be tightly coupled either to particular service implementations or to particular consumers as they exist today. By keeping implementation details out of the schema, it should be possible to refactor the services that implement the graph – for example, transitioning from a monolith to microservices, or changing the language in which a service is implemented – without disturbing apps in the field. Likewise, the schema shouldn't be tightly coupled to the way that particular apps fetch data. It should be possible to write new apps with minimal changes to the graph if their functionality is similar to that of existing apps.</p>
           To accomplish this, use the standard of a <i>demand-oriented</i> schema: a schema focused on providing a great developer experience to an app developer building a new feature against the existing graph. Aiming for this standard will help prevent the graph from becoming coupled to a service implementation that could change in the future, and help increase the reuse value of each field added to the graph.
           <br>
           <p><b>Use an Agile Approach to Schema Development. </b><i> The schema should be built incrementally based on actual requirements and evolve smoothly over time.</i></p>
           <p>It may be tempting to try to define, ahead of time, the “perfect schema” for all of your organization's data. Rather, what really makes a schema valuable is the degree to which it follows actual user requirements, which are never known perfectly up front and are constantly changing. The true path to the “perfect schema” is to make it easy for the graph to evolve in response to actual needs.</p>
           Fields shouldn't be added to the schema speculatively. Ideally, each field should be added only in response to a concrete need by a consumer for additional functionality, while being designed for maximum reuse by other consumers that have similar needs. <br>
           <p>Updating the graph should be a continuous process. Rather than releasing a new “version” of the graph periodically, such as every 6 or 12 months, it should be possible to change the graph many times a day if necessary. New fields can be added at any time. To remove a field, it is first deprecated, and then removed when no consumers use it. The schema registry enables this agile evolution of the graph, together with processes and tooling that keep everyone aware of changes that could affect them. This ensures that only fully vetted changes can go into production.</p>
           
           <p><b>Iteratively Improve Performance. </b> <i>Performance management should be a continuous, data-driven process, adapting smoothly to changing query loads and service implementations.</i></p>
           The graph layer is the right place to hold the conversation about performance and capacity that always must occur between services teams and the app developers that consume their services. This conversation should be an ongoing process that gives service developers continuous and proactive visibility into what consumers intend to do with their services.
           <p>Rather than optimizing every possible use of the graph, the focus should be on supporting the actual query shapes that are needed in production. Tooling should extract proposed new query shapes and surface them, before they go into production, to all affected service teams with latency requirements and projected query volume. Once the query is in production, its performance should be continuously monitored. If this principle is followed, problems should be easy to track back to the service that is not behaving as expected.</p>
           
           <p><b>Use Graph Metadata to Empower Developers. </b><i>Developers should be equipped with rich awareness of the graph throughout the entire development process.</i></p>
           A major part of GraphQL's value is the massive productivity boost that it gives to developers. To maximize this boost, a developer's tooling should give them ubiquitous awareness of the graph, threaded through all of the tools that they use throughout the entire development lifecycle.
           <p>Whenever a developer is doing work that relates to managing data or connecting to services, their tooling should put live information about the graph at their fingertips. This information should always be up-to-date and the tooling should be highly intelligent, applying graph awareness to the situation at hand in helpful and powerful ways. When done properly, not only does developer productivity and happiness increase, but GraphQL becomes the fabric that connects the frontend and backend teams, enabling seamless conversations throughout the development lifecycle.</p>
          <p>Some practical examples of the power of data-graph-aware tooling include:</p>
              <ul>
                <li>Developers can enjoy live documentation of all available graph data and services, right in their editor and always up-to-date.</li>
                <p> <li>Information about deprecated fields can be broadcast into the editors of developers using those fields, together with suggested alternatives</li>
                <li>The estimated cost of a query (in latency or server resources) can be shown to a developer as they're typing it, based on live production data.</li>
                <p> <li>The operations team can trace load on backend services back to a particular app, version, feature, and even line of code, giving them full visibility into how developers are using their service.</li>
                  <p> <li>When a service developer makes a change to their schema, the impact of that change can automatically be determined as part of the continuous integration process. If the change would break existing clients (as determined by replaying recent production usage), then the service developer can determine the precise clients, versions, and developers that will be affected.</li>
               <p> <li>As app developers are building features, the new queries that power those features can be extracted from their code and shared with the operations team. With this awareness, the operations team can proactively provision the needed capacity and interject early in the development process if the query can't be approved at the intended scale.</li>
                <p>  <li>When apps are developed in a typed language like TypeScript, Java, or Swift, type information can be propagated all the way from service type declarations through every line of code in the app, ensuring fullstack type correctness and instant feedback on errors.</li>
              </ul>
          </ul>
           <h4>Operations Principles</h4>
             <ul>
              <p><b>Access and Demand Control. </b><i>Grant access to the graph on a per-client basis, and manage what and how clients can access it.</i> </p>
               <p>Authorization in a graph has two equally important aspects: access control, which dictates which objects and fields a user is allowed to access, and demand control, which dictates how (and how much) the user is allowed to access those resources. While access control is often talked about, attention also needs to be given to demand control, since it is critical in any production deployment of GraphQL. It is a mistake to allow users to perform any possible query regardless of cost, with no ability to manage its impact on production systems. Both access and demand control must be performed with full awareness of the semantics and performance of the graph. It's not sufficient to limit a user to particular number of queries per minute without an analysis of the queries actually being sent, as a query could access a wide universe of services and the cost of a query can vary over multiple orders of magnitude.</p>
               Authentication in a graph also has two aspects: the app that is requesting the operation, and the person that is using the app. While access control may center on the person using the app, proper demand control depends at least as much on per-app controls as it does on per-person controls, as it is the developer of the app, not the user of the app, that is responsible for the particular query shapes that the app uses to do its job.
                <br> 
                <p>Best practices for demand control include:</p>
                    <ul>
                      <li>When untrusted users are accessing production systems, they should only send queries that have been preregistered by the authenticated developer of the app, instead of allowing them to send arbitrary queries with the app's credentials. This is sometimes relaxed for internal apps that are distributed only to trusted users.</li>
                     <p> <li>For apps that are expected to send large numbers of queries, teams should design a query approval workflow, aligned with the broader software development cycle, to vet queries before they go into production. This ensures that they do not fetch unnecessary data and that server capacity is available to support them.</li></p>
                     <p> <li>As a second line of defense, estimating the cost of a query before performing it and instituting per-user and per-app query cost budgets can protect against overuse of preregistered operations or in cases where operation preregistration is not possible.</li></p>
                      <li>Developers should be able to disable the ability of particular apps to send particular queries in production, either as a safety net in emergencies or if a third party app is found to be using the graph in unacceptable ways.</li>
                    </ul>

              <p><b>Structured Logging. </b> <i>Capture structured logs of all graph operations and leverage them as the primary tool for understanding graph usage.</i></p>
              A wealth of information can be captured about each operation (read or write) that is performed on a graph: what user and app performed the operation, what fields were accessed, how the operation was actually executed, how it performed, and more. This information is highly valuable and should be systematically captured and made available for later use. Instead of a text log, it should be captured in a structured, machine readable format so that it can be leveraged for as many purposes as possible.
              <p>The record of a graph operation is called a trace. A trace should bring together all pertinent information about an operation in one place, including business information (who performed the operation, what was accessed or changed, which feature of which app built by which developer, whether it succeeded, how it performed) and purely technical information (which backend services were contacted, how each service contributed to latency, whether caches were used).</p>
              <p>Because traces truly capture how a graph is being used, they can be used for a wide range of purposes:</p>
                    <ul>
                      <p><li>Understanding whether a deprecated field can be removed, or if not, the specific clients that are still accessing it and how important they are.</li>
                      <p><li>Predicting how long a query will take to execute – in realtime, as the developer is typing the query in their IDE – based on live production data.</li>
                      <p><li>Automatically detecting problems in production (such as increased latency or error rates) and diagnosing their root cause.</li>
                      <p><li>Providing an authoritative audit trail showing which users have accessed a particular record.</li>
                      <p><li>Powering business intelligence queries.</li>
                      <p><li>Generating invoices for partners based on API usage, with the possibility of a detailed cost model based on either the particular fields accessed or the resources consumed.</li>
                    </ul>
                    <p>Traces for all graph operations should be collected in one central place, so that there is one authoritative stream of traces. This stream can then be piped into other observability systems (perhaps after a simple transformation for existing systems that are not GraphQL-aware), or stored in one or more data warehouses for later use (aggregated and sampled as budget, use cases, and scale require).</p>
               <p><b>Separate the GraphQL Layer from the Service Layer. </b> <i> Adopt a layered architecture with graph functionality broken into a separate tier rather than baked into every service.</i></p>
               In most API technologies, clients do not talk directly to servers, except possibly in development. Instead, a layered approach is adopted in which some concerns such as load balancing, caching, service location, or API key management are split into a separate tier. This tier can then be designed, operated, and scaled separately from the backend services.
               <p>It's no different with GraphQL. Rather than baking all of the functionality needed for a complete graph system into each and every service, most graph functionality should be factored out into a separate tier that sits in between clients and services, leaving each service to focus on serving the actual client request. This tier, which can be composed of multiple processes, performs functions such as access and demand control, federation, trace collection, and potentially caching. Some parts of this tier will be GraphQL-specific and require deep awareness of the graph, while other functions such as load balancing and client authentication can likely be performed by systems that are already in place.</p>
               This separate tier is valuable even in simple scenarios with only one app and only one service; otherwise, functionality that properly belongs in the middle tier will have to be implemented in the server. In complex applications, this tier may start to look like a geographically distributed system: receiving incoming queries through multiple ingress points, processing some of them on the edge of the network with the benefit of edge caches, routing subcomponents of the queries to multiple data centers in the public cloud, privately operated, or operated by partners, and finally assembling these components into a query result, all while recording a trace that memorializes the entire operation.
               <p>In some cases, this graph tier will talk to the backend services using GraphQL. But, most frequently, the backend services are left untouched and continue to be accessed by their existing APIs, such as REST, SOAP, gRPC, Thrift, or even SQL, with the mapping from these APIs to graph objects accomplished by servers that form one part of the graph tier.</p>
                  </ul>


                  
                </section>
    </section>
                
    <section id="RESTvsGraph">
     <h2>Rest vs GraphQL</h2>
        <h3>Main Differences between GraphQL and REST</h3>

        <p>GraphQL and REST are two design approaches that focus on the same function: data transmission through internet protocols such as HTTP. However, the implementation is where they branch out. Here are a few factors to be analized to shed light on the topic of GraphQL vs REST:</p>
        <ul>
          <li>Usability</li>
          <li>Performance</li>
          <li>Security</li>
          <li>Popularity</li>
          <li>Data Fetching</li>
        </ul>

        <section id="Usability">
            <h3>Usability</h3>

          <p>When it comes to GraphQL vs REST usability, the two differ significantly in terms of both <b>Versioning and Predictability</b>. An important benefit of GraphQL is its high predictability.</p>
          <p>It allows you to send a request to your API and get the exact results you require without unwanted inclusions. GraphQL queries return predictable results which significantly improves their usability.</p>
        <p>REST’s behavior, on the other hand, varies based on the <b>HTTP and URI</b> methods used. This can make it unclear for an API consumer to know what to expect when calling an endpoint.</p>
       <p>In terms of Versioning, REST doesn’t have standardized and clear guidelines for it. This means that every provider is free to implement their approach. On the other end of the spectrum, you have GraphQL. It follows a very simple approach to versioning: <b>don’t version APIs</b>.</p>

       <p>Therefore, if you were to compare GraphQL vs REST API in terms of versioning and predictability, GraphQL’s simplicity gives it an edge over REST.</p>
       


      </section>

        <section id="Performance">
           <h3>Performance</h3>

           <p>In terms of GraphQL vs REST performance, the inclination for <b>Over-fetching and Under-fetching</b> in RESTful services gives GraphQL a clear edge. Since REST APIs have inherently rigid data structures designed to return the stipulated data whenever they get hit, you may end up accumulating unwanted data or be forced to make multiple calls before getting the relevant data. These inadequacies can escalate the time it takes for the server to return the requested information.</p>
        <p>On the contrary, GraphQL uses a flexible style that allows you to retrieve what you need in a single API request. After defining the structure of the information you need, the same structure will be returned to you from the server, which avoids over-fetching and under-fetching.</p>
          <p>Generally, the GraphQL vs REST debate on performance flags GraphQL as the winner, but there are a few use cases where REST APIs are a better alternative. For example, in cases where <b>caching is desired to expedite API calls</b>.</p>
          
          <h4>Example of a webpage using REST calls at Swapi API and graphQL calls at swapi wrapper : </h4>
          <img src="images/graphql.png" alt="REST request image" style="width:1100px;height:900px;">
          <p>  The results show that graphQL calls render way faster, everytime over REST calls.</p>
     
        </section>

       <section id="Security">
        <h3>Security</h3>
        <p>When talking about GraphQL vs REST in terms of security, the credit seems to be leaning towards REST. REST provides several ways to enforce the security on your APIs.</p>
        <p>For instance, you can ensure REST API security by implementing multiple API authentication methods like <b>HTTP authentication</b>. Here, sensitive data is sent in HTTP headers, through JSON Web Tokens, where sensitive data is sent as JSON data structures, or through OAuth 2.0 mechanisms.</p>
        <p>GraphQL also provides some measures to ensure your APIs’ security, but they are not as mature as those of REST. For instance, although GraphQL assists in integrating data validation, users are left to figure out how to apply authorization and authentication measures on top. </p>
        <h4>Example of a authorized request in REST:</h4>
        <img src="images/authorized.png" alt="REST request image" style="width:700px;height:500px;">
      </section>

       <section id="Popularity">
        <h3>Popularity</h3>
<p>In terms of popularity, the GraphQL vs REST debate leans towards REST APIs. For instance, according to a State of API 2020 <a href="https://nordicapis.com/breaking-down-smartbears-2020-state-of-api-report/">Report</a>, around <b>82%</b> of the surveyed API consumers and practitioners use REST-based OpenAPI authentication, while only <b>18%</b> use GraphQL.</p>
        <img src="images/popularity1.jpg" alt="REST structure image" style="width:900px;height:400px;">
        <p>However, GraphQL’s popularity has been steadily surging. According to the State of JavaScript 2019 Report, while only <b>5%</b> of those surveyed had used it in 2016, the numbers had gone up to <b>38.7%</b> in 2019 and still surging.</p>

      </section>

       <section id="Data Fetching">
        <h3>Data Fetching</h3>

        <p>In terms of data fetching in GraphQL vs REST, REST API gathers data by accessing multiple endpoints. Using the hierarchy, takes different routes or endpoints.</p>
       <p>Like <b>/people/id</b> will be one endpoint to fetch the user data, <b>/people/id/age</b> will be another endpoint to get the age of the user, and <b>/people/id/films</b> will fetch a list of films of the person.</p>
       <p>On the other hand in GraphQL, you can simply send a query to the GraphQL server that includes the data requirements and the server will respond with a JSON object.</p>
       
       <h4>Example of a fetch REST request:</h4>
       <img src="images/RESTreq.png" alt="REST request image" style="width:900px;height:400px;">
       <h4>Example of a fetch GraphQL request (with query):</h4>
       <img src="images/graphQLrequest.png" alt="REST request image" style="width:800px;height:800px;">
      </section>
      </section>
      <section id="Conclusion">
        <h3>Conclusions</h3>
        GraphQL has many advantages over REST. GraphQL is faster than REST because you can easily pick the fields you have to query. GraphQL provides a better learning curve as compared to REST.

        <p> GraphQL has generated a large amount of excitement in the developer community, so one can assume that it does solve some genuine problems that plague traditional RESTful APIs, and ten years down the line it may even be the standard for writing new APIs on the web—or perhaps not. The reality of the situation is that GraphQL is still relatively new to the game and only time will tell if it really matches all the advantages and convenience that REST provides. REST is still the undeniably more mature option when it comes to tooling, analytics, caching, and overall developer familiarity.</p>
        <p> In a world of SoA, you are likely to have multiple services, which expose multiple APIs. So why not use both?</p>
        One mix of REST and GraphQL could just be adding a /graphql endpoint to api.whatever.com and having that as your GraphQL endpoint on an REST API.
      </section>
      <section id="Bibliography">
        <h3>Bibliography</h3>

        <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">Fielding, Roy Thomas (2000) - https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a> <br>
        <a href="https://datatracker.ietf.org/doc/html/rfc7231#section-4">Fielding, Roy (June 2014)-https://datatracker.ietf.org/doc/html/rfc7231#section-4 </a> <br>
        <a href="https://restfulapi.net">RESTful API -https://restfulapi.net </a> <br>
        <a href="https://www.researchgate.net/publication/281287283_A_Maturity_Model_for_Semantic_RESTful_Web_APIs">Web Services - https://www.researchgate.net/publication/281287283_A_Maturity_Model_for_Semantic_RESTful_Web_APIs </a> <br>
        <a href="https://en.wikipedia.org/wiki/GraphQL"> GraphQL- https://graphql.org</a> <br>
        <a href="https://phil.tech/2017/graphql-vs-rest-overview/"> GraphQl vs REST -https://phil.tech/2017/graphql-vs-rest-overview/</a> <br>
        <a href="https://github.com/graphql/graphql-spec/releases/tag/June2018">GraphQL release notes-https://github.com/graphql/graphql-spec/releases/tag/June2018</a> <br>
      </section>

     


  
   
  </body>
  
</html>


